/*
# This file is autogenerated
# Do not modify
*/

#ifndef ENV_HPP_
#define ENV_HPP_

#include "verilated_vcd_sc.h"
#include <systemc>
#include <uvm>

{% for fn in hdr_files -%}
  #include "{{ fn }}"
{% endfor %}

#include "{{env.din_seq.name}}.hpp"
#include "scoreboard.hpp"

{% for port in ports -%}
  #define W_{{port.basename.upper()}} {{dut.intf_w(port) }}
{% endfor %}

{% for port in ports -%}
  using vif_{{port.basename}}_type = dti_vif<sc_dt::sc_uint<W_{{port.basename.upper()}}> >;
{% endfor %}

{% for port in ports -%}
  using {{port.basename}}_packet_type = {{dut.packet_type_str(port)}};
{% endfor %}

template <class MODULE> class env : public uvm::uvm_env {
public:
MODULE dut;
VerilatedVcdSc *m_trace;

{% for port in ports -%}
  dti_agent<vif_{{port.basename}}_type, {{port.basename}}_packet_type > *{{port.basename}}_agent;
{% endfor %}
scoreboard *sb;

{% for port in dut.in_ports -%}
  {{port.basename}}_sequence<{{port.basename}}_packet_type> *{{port.basename}}_seq;
{% endfor %}

sc_core::sc_time T;

sc_clock clk;
sc_signal<bool> rst;

{% for port in ports -%}
  vif_{{port.basename}}_type *{{port.basename}}_vif;
{% endfor %}

UVM_COMPONENT_UTILS(env);

env(uvm::uvm_component_name name, const char *dut_name, const char *vcdname) :
uvm::uvm_env(name),
dut(dut_name),
T(10, SC_NS),
clk("clk", T),
rst("rst")
{
m_trace = new VerilatedVcdSc;
Verilated::traceEverOn(true);
open_trace(vcdname);
}

void build_phase(uvm::uvm_phase& phase)
  {

    uvm::uvm_env::build_phase(phase);
    uvm_config_db_options::turn_on_tracing();

{% for port in ports -%}
  {{port.basename}}_vif = new vif_{{port.basename}}_type(&clk, &rst);
{% endfor %}

{% for port in ports -%}
    {{port.basename}}_agent = dti_agent<vif_{{port.basename}}_type, {{port.basename}}_packet_type>::type_id::create("{{port.basename}}_agent", this);
    assert({{port.basename}}_agent);
    uvm::uvm_config_db<int>::set(this, "{{port.basename}}_agent", "is_active", uvm::UVM_ACTIVE);
    uvm::uvm_config_db<Mode_T>::set(this, "{{port.basename}}_agent.*", "mode", {{dut.agent_type(port)}});
    uvm::uvm_config_db<vif_{{port.basename}}_type *>::set(0, "env.{{port.basename}}_agent.*", "vif", {{port.basename}}_vif);

{% endfor %}
    sb = scoreboard::type_id::create("sb", this);
    assert(sb);

{% for port in dut.in_ports %}
  {{port.basename}}_seq = {{port.basename}}_sequence<{{port.basename}}_packet_type>::type_id::create("{{port.basename}}_seq");
{% endfor %}
}

void connect_phase(uvm::uvm_phase& phase){
    dut.clk(clk);
    dut.rst(rst);

{% for port in ports -%}
  dut.{{port.basename}}_ready({{port.basename}}_vif->dti_ready);
  dut.{{port.basename}}_valid({{port.basename}}_vif->dti_valid);
  dut.{{port.basename}}_data({{port.basename}}_vif->dti_data);

{% endfor %}

{% for port in ports -%}
  {{port.basename}}_agent->monitor->item_collected_port.connect(sb->{{port.basename}}_listener_imp);
{% endfor %}

}

  void reset_phase(uvm::uvm_phase &phase) {
    phase.raise_objection(this);
    reset();
    phase.drop_objection(this);
  }

  void final_phase(uvm::uvm_phase &phase) {
    close_trace();
  }

{% for port in dut.in_ports %}
  void start_{{port.basename}}_seq(){
  {{port.basename}}_seq->start({{port.basename}}_agent->sequencer);
  {{port.basename}}_seq->wait_for_sequence_state(uvm::UVM_FINISHED);
  }

{% endfor %}


  virtual void main_phase(uvm::uvm_phase &phase) {
    phase.raise_objection(this);

SC_FORK
{% for port in dut.in_ports %}
  sc_core::sc_spawn(sc_core::sc_bind(&env::start_{{port.basename}}_seq, this)),
{% endfor %}
SC_JOIN

    phase.drop_objection(this);
  }

  virtual void reset(void) {
    rst = 1;
    sc_core::wait(2 * T);
    rst = 0;
  }

  virtual void open_trace(const char *vcdname) {
    dut.trace(m_trace, 10);
    m_trace->open(vcdname);
  }

  virtual void close_trace(void) {
    m_trace->close();
    m_trace = NULL;
  }

};

#endif
